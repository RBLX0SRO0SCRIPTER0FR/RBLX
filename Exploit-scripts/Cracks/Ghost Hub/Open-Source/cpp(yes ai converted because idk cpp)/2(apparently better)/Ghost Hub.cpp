#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <curl/curl.h>

// libcurl write callback
static size_t WriteCallback(void* contents, size_t size, size_t nmemb, void* userp) {
    std::string* buf = reinterpret_cast<std::string*>(userp);
    buf->append((char*)contents, size * nmemb);
    return size * nmemb;
}

// Simple HTTP GET with Roblox-style UA
std::string http_get(const std::string& url) {
    CURL* curl = curl_easy_init();
    std::string data;
    if (curl) {
        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
        curl_easy_setopt(curl, CURLOPT_USERAGENT, "Roblox/WinInet");
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &data);
        curl_easy_perform(curl);
        curl_easy_cleanup(curl);
    }
    return data;
}

// Extract between prefix + suffix
std::string extract_between(const std::string& text, const std::string& start, const std::string& end) {
    size_t s = text.find(start);
    if (s == std::string::npos) return "";
    s += start.size();
    size_t e = text.find(end, s);
    if (e == std::string::npos) return "";
    return text.substr(s, e - s);
}

// Decode ASCII codes separated by '\'
std::string decode_ascii(const std::string& encoded) {
    std::string out;
    size_t i = 0, n = encoded.size();
    while (i < n) {
        if (encoded[i] == '\\') {
            ++i;
            int val = 0;
            bool valid = false;
            while (i < n && isdigit(encoded[i])) {
                val = val * 10 + (encoded[i] - '0');
                ++i;
                valid = true;
            }
            if (valid) out.push_back((char)val);
        } else {
            ++i;
        }
    }
    return out;
}

// Decrypt payload
std::string decrypt(const std::string& source, const std::string& key) {
    std::string out;
    out.reserve(source.size() / 2); // rough guess

    size_t i = 0, n = source.size(), ki = 0;
    while (i < n) {
        int val = 0;
        bool valid = false;
        while (i < n && isdigit(source[i])) {
            val = val * 10 + (source[i] - '0');
            ++i;
            valid = true;
        }
        if (valid) {
            int k = (int)key[ki % key.size()];
            char decoded = (char)((val - k + 256) % 256);
            out.push_back(decoded);
            ++ki;
        }
        if (i < n && source[i] == '/') ++i;
    }
    return out;
}

int main() {
    // Stage 1: fetch obfuscated loader
    std::string raw = http_get("https://anti-httpspy.scriptsobfuscator.workers.dev/Ghost%20Hub");

    // Stage 2: extract and decode ASCII block
    std::string ascii_encoded = extract_between(raw, "(\"", "\")");
    std::string loader = decode_ascii(ascii_encoded);

    // Stage 3: extract key + URL from loader
    std::string key = extract_between(loader, "[12]=\"", "\"");
    std::string url = extract_between(loader, "HttpGet(\"", "\")");

    std::cout << "Key: " << key << "\n";
    std::cout << "URL: " << url << "\n";

    // Stage 4: fetch encrypted GhostHub payload
    std::string enc = http_get(url);

    // Stage 5: extract encrypted payload string
    std::string source = extract_between(enc, "end)(\"", "\"");

    // Stage 6: decrypt
    std::string ghosthub = decrypt(source, key);

    // Stage 7: print preview
    std::cout << "\nGhostHub (first 10 lines):\n";
    size_t pos = 0, count = 0;
    while (count < 10 && (pos = ghosthub.find('\n')) != std::string::npos) {
        std::cout << ghosthub.substr(0, pos) << "\n";
        ghosthub.erase(0, pos + 1);
        ++count;
    }

    // Stage 8: write to file
    std::ofstream out("Ghost Hub.lua", std::ios::binary);
    out << ghosthub;
    out.close();

    std::cout << "\nSaved to Ghost Hub.lua\n";
    return 0;
}
